#include <iostream>
#include <iomanip>
#include <vector>
#include <math.h>
//#include "LUdcmp.h"

using namespace std;
extern "C" {
  void dgetrf_(int* M, int *N, double* A,
	       int* LDA, int* IPIV, int* INFO);
  void dgetrs_(char* TRANS, int* N, int* NRHS, double* A,
	       int* LDA, int* IPIV, double* B, int* LDB, int* INFO);
}

void initialize_matrix(vector<vector<double> > &matrix, const double value)
{
  int N=matrix.size();//matrix rows
  int M=matrix[0].size();//matrix columns
  for (int i=0; i<N; i++)
	  for (int j=0; j<M; j++)
		  matrix[i][j]=value;
}

void print_matrix(const vector<vector<double> > &matrix)
{
	int N=matrix.size();//matrix rows
	int M=matrix[0].size();//matrix columns
	cout << endl;
	for (int i=0; i<N; i++)
	{
		for (int j=0; j<M; j++)
			cout << "\t" << matrix[i][j];
		cout << endl;
	}
	cout << endl;
}

void print_vector(const vector<double> &vector)
{
	int N=vector.size();
	cout << endl;
	for (int i=0; i<N; i++)
	{
		cout << vector[i] << endl;
	}
	cout << endl;
}

class LapackLUdcmp
{
public:
	LapackLUdcmp(vector<vector<double> > &matrix);
//	void solve();
	double det();
private:
	int N; //matrix rows
	int M; //matrix columns
	int *IPIV;
	int INFO;
//	int LWORK;
	double *LU;
//	double *WORK;
};

LapackLUdcmp::LapackLUdcmp(vector<vector<double> > &matrix)
{
	N=matrix.size();
	M=matrix[0].size();
	//	LWORK=N*N;
	//	WORK=new double[LWORK];
	LU = new double[N*M];
	IPIV=new int[N+1];
	INFO=0;
	/*
	 * express matrix in column major form for fortran
	 */
	for (int i=0; i<N; i++)
		for (int j=0; j<M; j++)
			LU[M*j+i]=matrix[i][j];

	dgetrf_(&N,&N,LU,&N,IPIV,&INFO);//lapack_ludcmp
	/*
	 * transfer result to matrix
	 */
	for (int i=0; i<N; i++)
		for (int j=0; j<M; j++)
			matrix[i][j]=LU[M*j+i];
}

double LapackLUdcmp::det()
{
	double determinant=1.;
	for (int i=0; i<N; i++)
		determinant*=LU[i*N+i];

	int sign=1;
	for (int i=0; i<N; i++)
	{
		if (IPIV[i]!=i+1)
			sign=-sign;
	}
	return sign*determinant;
}

class AnalyticCompositeRegion
{
public:
  AnalyticCompositeRegion();
  void find_roots(const unsigned int number_of_roots,
		  vector<double> &roots);
  void find_coefficients(const vector<double> &roots,
			 vector<double> &C, vector<double> &D);
  double find_value(const double position, const double time_in_seconds, const vector<double> &roots,
		    const vector<double> &C, const vector<double> &D);
  void form_matrix_simple(
			  vector<vector<double> >& matrix,
			  const double beta);
  double top_external_temperature(double time_in_seconds);

  double Psi(double A, double x);
  double Phi(double A, double x);
  double Psi_der(double A, double x);
  double Phi_der(double A, double x);
private:
  unsigned int number_of_layers;
  unsigned int number_of_equations;
  double initial_condition;
  double boundary_amplitud;
  double boundary_period;
  double boundary_phase;

  vector<double> k;
  vector<double> rho;
  vector<double> cp;
  vector<double> alpha;
  vector<double> x;
  vector<double> h;
};

AnalyticCompositeRegion::AnalyticCompositeRegion():
  number_of_layers(5),
  number_of_equations(2*number_of_layers),
  initial_condition(0.),
  boundary_amplitud(10.),
  boundary_period(86400.),
  boundary_phase(54000.),
  k(number_of_layers),
  rho(number_of_layers),
  cp(number_of_layers),
  alpha(number_of_layers),
  x(number_of_layers+1),
  h(2)
{
  k[0]=(1.100);
  k[1]=(0.220);
  k[2]=(0.703);
  k[3]=(0.160);
  k[4]=(1.945);
  
  rho[0]=(1.000);
  rho[1]=(1.000);
  rho[2]=(1.000);
  rho[3]=(1.000);
  rho[4]=(1.000);
  
  cp[0]=(2166710);
  cp[1]=(1440000);
  cp[2]=(3386960);
  cp[3]=(1296000);
  cp[4]=(2941120);
  
  alpha[0]=(k[0]/(rho[0]*cp[0]));
  alpha[1]=(k[1]/(rho[1]*cp[1]));
  alpha[2]=(k[2]/(rho[2]*cp[2]));
  alpha[3]=(k[3]/(rho[3]*cp[3]));
  alpha[4]=(k[4]/(rho[4]*cp[4]));
  
  x[0]=( 0.000);
  x[1]=( 0.103);
  x[2]=( 0.107);
  x[3]=( 0.152);
  x[4]=( 0.155);
  x[5]=( 0.610);

  h[0]=(10000000.000);
  h[1]=( 0.000);
}

double AnalyticCompositeRegion::top_external_temperature(const double time_in_seconds)
{
  return (15.+boundary_amplitud*cos((2.*M_PI/boundary_period)*(time_in_seconds-boundary_phase)));
}

void AnalyticCompositeRegion::find_roots(const unsigned int number_of_roots,
					 vector<double> &roots)
{
  int Eq=number_of_equations;
  vector<vector<double> > matrix(Eq,vector<double>(Eq));
  
  double delta=0.00001;
  double epsilon=1.E-13;
  double a=1.E-11;
  double b=a+delta;
  double fa=0.;
  double fb=0.;
  /*
   * Initial guesses fa, fb
   */
  form_matrix_simple(matrix,a);
  LapackLUdcmp lapack_ludcmp(matrix);
  fa=lapack_ludcmp.det();
  
  form_matrix_simple(matrix,b);
  lapack_ludcmp=LapackLUdcmp(matrix);
  fb=lapack_ludcmp.det();
  /*
   * Find the roots (betas)
   */
  for (unsigned int i=0; i<number_of_roots; i++)
    {
      while (fa*fb>0)// find next interval where the root lies
	{
	  a=b;
	  b=b+delta;
	  
	  form_matrix_simple(matrix,a);
	  lapack_ludcmp=LapackLUdcmp(matrix);
	  fa=lapack_ludcmp.det();

	  form_matrix_simple(matrix,b);
	  lapack_ludcmp=LapackLUdcmp(matrix);
	  fb=lapack_ludcmp.det();
	}
      unsigned int step=0;
      while (fabs(a-b)>epsilon)
	{
	  double c=(a+b)/2.;
	  form_matrix_simple(matrix,c);
	  lapack_ludcmp=LapackLUdcmp(matrix);
	  double fc=lapack_ludcmp.det();

	  if (fc*fa<0.)
	    {
	      b=c;
	      fb=fc;
	    }
	  else
	    {
	      a=c;
	      fa=fc;
	    }
	  if (step>90 && step<=100)
	    cout << "\troot interval f(" << a << "): " << fa << "\tf(" << b << "): "
		 << fb << "\tepsilon: " << fabs(a-b)  << "\tf(" << c << "): " << fc << endl;
	  step++;
	}
      a=b;
      fa=fb;
      /*
       * We found a root, calculate the coefficients
       */
      {
	form_matrix_simple(matrix,a);
	lapack_ludcmp=LapackLUdcmp(matrix);

	vector<double>X(Eq);
	X[Eq-1]=1.;// this is the free variable and we give a value arbitrarily X3, D2
	for (unsigned int i=1; i<Eq; i++)
	  {
	    for (unsigned int j=Eq-i; j<=Eq-1; j++)
	      X[Eq-i-1]-=matrix[Eq-i-1][j]*X[j];
	    X[Eq-i-1]/=matrix[Eq-i-1][Eq-i-1];
	  }

	roots.push_back(b);
	//			for (unsigned int i=0; i<Eq; i++)
	//			{
	//				if (i%2==0)
	//					C.push_back(X[i]);
	//				else
	//					D.push_back(X[i]);
	//			}
      }
    }
}

void AnalyticCompositeRegion::find_coefficients(const vector<double> &roots,
						vector<double> &C, vector<double> &D)
{
  int Eq=number_of_equations;
  vector<vector<double> > matrix(Eq,vector<double>(Eq));
  LapackLUdcmp lapack_ludcmp(matrix);
  for (unsigned int beta=0; beta<roots.size(); beta++)
    {
      form_matrix_simple(matrix,roots[beta]);
      lapack_ludcmp=LapackLUdcmp(matrix);
      vector<double>X(Eq);
      X[Eq-1]=1.;// this is the free variable and we give a value arbitrarily X3, D2
      for (unsigned int i=1; i<Eq; i++)
	{
	  for (unsigned int j=Eq-i; j<=Eq-1; j++)
	    X[Eq-i-1]-=matrix[Eq-i-1][j]*X[j];
	  X[Eq-i-1]/=matrix[Eq-i-1][Eq-i-1];
	}
      for (unsigned int i=0; i<Eq; i++)
	{
	  if (i%2==0)
	    C.push_back(X[i]);
	  else
	    D.push_back(X[i]);
	}
    }
}

double AnalyticCompositeRegion::find_value(const double position, const double time_in_seconds,
		const vector<double> &roots,
		const vector<double> &C, const vector<double> &D)
{
  double temperature_top=top_external_temperature(time_in_seconds);
  double temperature_top_initial=top_external_temperature(0.);
  unsigned int layer=0;
  for (unsigned int i=0; i<x.size(); i++)
    {
      if (position>=x[i] && position<=x[i+1])
	{
	  layer=i;
	  break;
	}
    }
  
  double solution=0.;
  double source_position=1.05;
  double period_source=1.;
  for (unsigned int i=0; i<roots.size(); i++)
    {
      double norm=0.;
      double In=0.;
      double Vn=0.;
      double fn=0.;
      double Gn=0;
      double GGnn=0.;
      for (unsigned int l=0; l<number_of_layers; l++)
	{
	  double Cl=C[number_of_layers*i+l];
	  double Dl=D[number_of_layers*i+l];
	  
	  double A=roots[i]/sqrt(alpha[l]);
	  
	  fn+=(k[l]/alpha[l])*(
			       (Cl/A)*(sin(A*x[l+1])-sin(A*x[l]))-
			       (Dl/A)*(cos(A*x[l+1])-cos(A*x[l])));
	  norm+=(k[l]/alpha[l])*(
				 pow(Cl,2.)*(x[l+1]/2.+sin(2.*A*x[l+1])/(4.*A)-x[l]/2.-sin(2.*A*x[l])/(4.*A))
				 +2.*Cl*Dl*(pow(sin(A*x[l+1]),2.)/(2.*A)-pow(sin(A*x[l]),2.)/(2.*A))
				 +pow(Dl,2.)*(x[l+1]/2.-sin(2.*A*x[l+1])/(4.*A)-x[l]/2.+sin(2.*A*x[l])/(4.*A)));
	  
	  In+=(k[l]/alpha[l])*(
			       (Cl/A)*(sin(A*x[l+1])-sin(A*x[l]))-
			       (Dl/A)*(cos(A*x[l+1])-cos(A*x[l])));
	  
	  GGnn+=(
		 (Cl/A)*(sin(A*x[l+1])-sin(A*x[l]))-
		 (Dl/A)*(cos(A*x[l+1])-cos(A*x[l])));
	  
	  
	  for (unsigned int g=1; g<=950; g++)
	    {
	      double period_source=1.;
	      double q=g*(2.*M_PI)/period_source;
	      Gn+=cos(q*source_position)*
		(Cl*(sin((A-q)*x[l+1])/(2.*(A-q))+sin((A+q)*x[l+1])/(2.*(A+q))
		     -sin((A-q)*x[l  ])/(2.*(A-q))-sin((A+q)*x[l  ])/(2.*(A+q)))+
		 Dl*(-cos((A-q)*x[l+1])/(2.*(A-q))-cos((A+q)*x[l+1])/(2.*(A+q))
		     +cos((A-q)*x[l  ])/(2.*(A-q))+cos((A+q)*x[l  ])/(2.*(A+q))))
		+
		sin(q*source_position)*
		(Cl*(-cos((q-A)*x[l+1])/(2.*(q-A))-cos((q+A)*x[l+1])/(2.*(q+A))
		     +cos((q-A)*x[l  ])/(2.*(q-A))+cos((q+A)*x[l  ])/(2.*(q+A)))+
		 Dl*(sin((q-A)*x[l+1])/(2.*(q-A))-sin((q+A)*x[l+1])/(2.*(q+A))
		     -sin((q-A)*x[l  ])/(2.*(q-A))+sin((q+A)*x[l  ])/(2.*(q+A))));
	    }
	}
      {
	double boundary_term=0.;
	{
	  double P=2.*M_PI/boundary_period;
	  boundary_term=
	    (-P*boundary_amplitud)*(1./(pow(roots[i],4.)+pow(P,2.)))*
	    (cos(P*boundary_phase)*(pow(roots[i],2.)*sin(P*time_in_seconds)-P*cos(P*time_in_seconds)+exp(-pow(roots[i],2.)*time_in_seconds)*P)
	     -sin(P*boundary_phase)*(pow(roots[i],2.)*cos(P*time_in_seconds)+P*sin(P*time_in_seconds)-exp(-pow(roots[i],2.)*time_in_seconds)*pow(roots[i],2.)));
	  boundary_term*=(In/norm);
	}
	
	double initial_term=0.;
	{
	  initial_term=(initial_condition-temperature_top_initial)*fn*exp(-pow(roots[i],2.)*time_in_seconds)/norm;
	}
	
	double source_term=0.;
	// {
	//   double source_amplitud=100.;
	//   double source_phase =54000.;
	//   double source_period=86400.;
	//   double P=2.*M_PI/source_period;
	
	//   //periodic source
	//   double Gt=-(1./(pow(roots[i],4.)+pow(P,2.)))*
	//     (cos(P*source_phase)*(pow(roots[i],2.)*sin(P*time_in_seconds)-P*cos(P*time_in_seconds)+exp(-pow(roots[i],2.)*time_in_seconds)*P)
	//      -sin(P*source_phase)*(pow(roots[i],2.)*cos(P*time_in_seconds)+P*sin(P*time_in_seconds)-exp(-pow(roots[i],2.)*time_in_seconds)*pow(roots[i],2.)));
	//   //constant source
	//   //double Gt=(1./pow(roots[i],2.))*(1.-exp(-pow(roots[i],2.)*time_in_seconds));
	
	
	//   double Gx=source_amplitud*
	//     (Gn/norm + 0.5*GGnn/norm)*(2./period_source);
	
	//   source_term=Gx*Gt;
	// }
	double Cl=C[number_of_layers*i+layer];
	double Dl=D[number_of_layers*i+layer];
	double A=roots[i]/sqrt(alpha[layer]);
	
	double time_coefficient=initial_term-boundary_term+source_term;
	
	double x_coeff=Cl*cos(A*position)+Dl*sin(A*position);
	
	solution+=
	  x_coeff*time_coefficient;
      }
    }
  return solution+temperature_top;
}

void AnalyticCompositeRegion::form_matrix_simple(vector<vector<double> >& matrix,
						 const double beta)
{
  unsigned int m=number_of_layers;
  vector<double> A(m);
  for (unsigned int i=0; i<m; i++)
    A[i]=beta/sqrt(k[i]/(rho[i]*cp[i]));

  initialize_matrix(matrix, 0.);//fill matrix with zeroes

  matrix[0][0]=h[0]*Phi(A[0], x[0])-k[0]*Phi_der(A[0], x[0]); //C0
  matrix[0][1]=h[0]*Psi(A[0], x[0])-k[0]*Psi_der(A[0], x[0]); //D0
  // matrix[0][2]=0.; //C1
  // matrix[0][3]=0.; //D1
  // matrix[0][4]=0.; //C2
  // matrix[0][5]=0.; //D2

  for (unsigned int i=1; i<m; i++)
    {
      matrix[2*i-1][2*(i-1)+0]= Phi(A[i-1], x[i]); //C0
      matrix[2*i-1][2*(i-1)+1]= Psi(A[i-1], x[i]); //D0
      matrix[2*i-1][2*(i-1)+2]=-Phi(A[i  ], x[i]); //C1
      matrix[2*i-1][2*(i-1)+3]=-Psi(A[i  ], x[i]); //D1

      matrix[2*i  ][2*(i-1)+0]= (k[i-1]/k[i])*Phi_der(A[i-1], x[i]); //C0
      matrix[2*i  ][2*(i-1)+1]= (k[i-1]/k[i])*Psi_der(A[i-1], x[i]); //D0
      matrix[2*i  ][2*(i-1)+2]=              -Phi_der(A[i  ], x[i]); //C1
      matrix[2*i  ][2*(i-1)+3]=              -Psi_der(A[i  ], x[i]); //D1
    }

  // matrix[2*m-1][0]= 0.; //C0
  // matrix[2*m-1][1]= 0.; //D0
  // matrix[2*m-1][2]= 0.; //C1
  // matrix[2*m-1][3]= 0.; //D1
  matrix[2*m-1][2*(m-1)+0]= h[1]*Phi(A[m-1], x[m])+k[m-1]*Phi_der(A[m-1], x[m]); //C2
  matrix[2*m-1][2*(m-1)+1]= h[1]*Psi(A[m-1], x[m])+k[m-1]*Psi_der(A[m-1], x[m]); //D2
}

double AnalyticCompositeRegion::Psi(double A, double x)
{
  return (sin(A*x));
}

double AnalyticCompositeRegion::Phi(double A, double x)
{
  return (cos(A*x));
}

double AnalyticCompositeRegion::Psi_der(double A, double x)
{
  return (A*cos(A*x));
}

double AnalyticCompositeRegion::Phi_der(double A, double x)
{
  return (-A*sin(A*x));
}

// void form_matrix(vector<vector<double> >& matrix, const double beta1)
// {
//   double h1=    16.000;
//   double h3=     8.000;
//   double x1=     0.050;
//   double x2=     0.100;
//   double x3=     0.200;
//   double k1=     0.038;
//   double k2=     2.200;
//   double rho1=  32.000;
//   double rho2=2300.000;
//   double cp1=  840.000;
//   double cp2=  880.000;
//   double a1=k1/(rho1*cp1);
//   double a2=k2/(rho2*cp2);

// //  double beta2=beta1;//*sqrt(a1/a2);

//   matrix[0][0]=h1*cos((M_PI/180.)*beta1*x1/sqrt(a1)) - /*(M_PI/180.)*/k1*(-beta1/sqrt(a1))*sin((M_PI/180.)*beta1*x1/sqrt(a1)); //C1
//   matrix[0][1]=h1*sin((M_PI/180.)*beta1*x1/sqrt(a1)) - /*(M_PI/180.)*/k1*( beta1/sqrt(a1))*cos((M_PI/180.)*beta1*x1/sqrt(a1)); //D1
//   matrix[0][2]=0; //C2
//   matrix[0][3]=0; //D2

//   matrix[1][0]= cos((M_PI/180.)*beta1*x2/sqrt(a1)); //C1
//   matrix[1][1]= sin((M_PI/180.)*beta1*x2/sqrt(a1)); //D1
//   matrix[1][2]=-cos((M_PI/180.)*beta1*x2/sqrt(a2)); //C2
//   matrix[1][3]=-sin((M_PI/180.)*beta1*x2/sqrt(a2)); //D2

//   matrix[2][0]= /*(M_PI/180.)*/k1*(-beta1/sqrt(a1))*sin((M_PI/180.)*beta1*x2/sqrt(a1)); //C1
//   matrix[2][1]= /*(M_PI/180.)*/k1*( beta1/sqrt(a1))*cos((M_PI/180.)*beta1*x2/sqrt(a1)); //D1
//   matrix[2][2]=-/*(M_PI/180.)*/k2*(-beta1/sqrt(a2))*sin((M_PI/180.)*beta1*x2/sqrt(a2)); //C2
//   matrix[2][3]=-/*(M_PI/180.)*/k2*( beta1/sqrt(a2))*cos((M_PI/180.)*beta1*x2/sqrt(a2)); //D2

//   matrix[3][0]=0; //C1
//   matrix[3][1]=0; //D1
//   matrix[3][2]=h3*cos((M_PI/180.)*beta1*x3/sqrt(a2)) + /*(M_PI/180.)*/k2*(-beta1/sqrt(a2))*sin((M_PI/180.)*beta1*x3/sqrt(a2)); //C2
//   matrix[3][3]=h3*sin((M_PI/180.)*beta1*x3/sqrt(a2)) + /*(M_PI/180.)*/k2*( beta1/sqrt(a2))*cos((M_PI/180.)*beta1*x3/sqrt(a2)); //D2
// }

int main()
{
  vector<double> positions(5);
  for (unsigned int i=0; i<62; i++)
    positions[i]=0.01*i;
  // positions[0]=0.00;
  // positions[1]=0.09;
  // positions[2]=0.160;
  // positions[3]=0.382;
  // positions[4]=0.610;
  // positions[5]=0.50;
  // positions[6]=0.61;
  // positions[7]=0.70;
  // positions[8]=0.80;
  // positions[9]=0.90;
  // positions[10]=1.00;

  vector<double> times(1);
   times[0]=  3600.*35.;
  // times[0]=  3600.;
  // times[1]= 10800.;
  // times[2]= 54000.;
  // times[3]= 97200.;
  // times[4]=118800.;

  unsigned int number_of_roots=5000;

  vector<double> roots;
  vector<double> coeff_C;
  vector<double> coeff_D;
  AnalyticCompositeRegion analytic_composite_region;
  analytic_composite_region.find_roots(number_of_roots,roots);
  analytic_composite_region.find_coefficients(roots,coeff_C,coeff_D);

  for (unsigned int t=0; t<times.size(); t++)
    {
      cout << "t: " << times[t] << " s\tTa: "
	   << analytic_composite_region.top_external_temperature(times[t]) << "\n";
      // for (unsigned int p=0; p<positions.size(); p++)
      // 	{
      // 	  cout << "x: " << positions[p] << "\tT: "
      // 	       << analytic_composite_region.find_value(positions[p],times[t],
      // 						       roots,coeff_C,coeff_D)
      // 	       << endl;
      // 	}
      // cout << endl;
    }
  
  cout << "X";
  for (unsigned int t=0; t<times.size(); t++)
    cout << "\tt: " << times[t]/3600. << "h";
  cout << endl;
  
  for (unsigned int p=0; p<positions.size(); p++)
    {
      cout << positions[p];
      for (unsigned int t=0; t<times.size(); t++)
	cout << "\t" << analytic_composite_region.find_value(positions[p],times[t],roots,coeff_C,coeff_D);
      cout << endl;
    }
  
//	for (unsigned int i=0; i<number_of_roots; i++)
//	{
//		cout << "i= " << i << "\tb= " << roots[i];
//		for (unsigned int l=0; l<3; l++)
//		{
//			double C=coeff_C[3*i+l];
//			double D=coeff_D[3*i+l];
//
//			cout << "\tC"<< l << ": " << C << "\t\tD" << l << ": " << D;
//		}
//		cout << "\n";
//	}
	return 1;
}
